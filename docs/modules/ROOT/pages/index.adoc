== Motivation
ServiceTalk is intended to provide a common and extensible networking abstraction on top of a lower-level networking
framework (e.g. link:https://netty.io[Netty]). Netty is a great low-level networking framework, but when used for
service to service communication it presents a few improvement opportunities:

* **Threading Model**
** fully asynchronous and requires knowledge of EventLoop threading model
** executing CPU intensive or "blocking" code requires manual thread hops
** Subtle out of order execution of tasks when code executes both on and off the EventLoop thread
* **Usability**
** APIs are not tailored toward common application use cases (e.g. request/response, RPC, etc..)
** Asynchronous programming paradigm presents a barrier to entry in scenarios where it may not be required for
scalability. It may be required as the user base grows, and only in subset of cases for the application.
** Error propagation follows multiple paths depending on the event and state of Channel
** back-pressure requires manual association between source and sink of data
* **Lacking Feature Set**
** Smart Client (e.g. client-side load balancing, service discovery, retry, circuit breaking, etc...) features missing

ServiceTalk addresses these challenges by providing a framework that supports multiple
xref:{page-version}@servicetalk::programming-paradigms.adoc[Programming Paradigms].
It accomplishes this by building on a fully asynchronous non-blocking I/O core and taking care of the threading
model complexities internally.

== Why ServiceTalk?

<TBD>

== Design Philosophy
ServiceTalk is designed to provide an extensible core and APIs tailored to networking protocols. ServiceTalk does not
intend to provide abstractions for low-level networking primitives (e.g. Channels, EventLoop, TLS, etc...) but instead
uses these primitives to provide a higher level API in multiple
xref:{page-version}@servicetalk::programming-paradigms.adoc[Programming Paradigms].

The project is divided into many modules to decouple the user-facing API from implementation details. This gives users
freedom to choose only the functionality they need, and also allows us to evolve each module independently. Note that
these modules may be divided out into independent repositories to decouple from the core and enable independent
versioning.
