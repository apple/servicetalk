include::ROOT:partial$component-attributes.adoc[]
= ServiceTalk

== Conceptual Overview
ServiceTalk is intended to provide a common and extensible networking abstraction on top of a lower-level networking
framework (e.g. link:https://netty.io[Netty]). Netty is a great low-level networking framework, but from the perspective
of application developers who need service to service communication it presents a few challenges:

* Threading Model
** fully asynchronous and requires knowledge of EventLoop threading model
** back-pressure requires manual association of source of data and sink of data
** executing CPU intensive or "blocking" code requires manual thread hops
** ordering issues when code executes both on and off the EventLoop thread
* Usability
** APIs not be tailored toward specific protocols (e.g. request/response, RPC, etc..)
** Asynchronous programming paradigm presents a barrier to entry in scenarios where it may not be required for
scalability. It may be required as the user base grows, and only in subset of cases for the application.
** Error propagation follows multiple paths depending on the event and state of Channel
* Lacking Feature Set
** Smart Client (e.g. client-side load balancing, service discovery, retry, circuit breaking, etc...) features missing

ServiceTalk addresses these challenges and provides a framework that supports multiple <<Programming Paradigms>>.
ServiceTalk accomplishes this by building on a fully asynchronous non-blocking I/O core and taking care of the threading
model complexities internally.

[#programming-paradigms]
=== Programming Paradigms
When developing a new application it may not be clear if the complexity of asynchronous control flow is justified.
Initially the scale may be relatively small, but over time the scale may grow. The scaling or response size
characteristics may not be uniform for all APIs offered by the application (e.g. health check vs file serving).
ServiceTalk is designed to evolve with your application so that you can get started quickly and avoid/defer the
complexity of asynchronous control flow in these cases. This can dramatically lower the bar to entry for ServiceTalk
compared with most non-blocking I/O frameworks and avoid "application re-write" if scaling/data size characteristics
change over time.

==== Blocking vs Synchronous
ServiceTalk APIs may use the term "blocking" in areas where the APIs may be identified as "synchronous". "blocking" in
this context is meant to declare that the API "may block" the calling thread. This is done because there is no general
way to determine if a method will return synchronously or block the calling thread, and "blocking" is the least common
denominator.

[#blocking-and-aggregated]
==== Blocking and Aggregated
This API paradigm is similar to concepts from `java.io` and generally blocks the calling thread until all I/O is
completed. The result is aggregated into a single object (e.g.
link:https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllLines-java.nio.file.Path-[Files.readAllLines]
).

==== Blocking and Streaming
This API paradigm is similar to concepts from `java.io` and generally blocks the calling thread until I/O is
flushed/received. The result can be provided/processed in a streaming fashion (e.g.
link:https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html[InputStream] or
link:https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html[OutputStream]) however processing each chunk of
the stream may also block the calling thread.

==== Asynchronous and Aggregated
This API paradigm performs I/O asynchronously (e.g. the calling thread is not blocked) and the user is notified when all
the I/O is complete. ServiceTalk provides a link:https://www.reactive-streams.org[ReactiveStreams] compatible
<<Asynchronous Primitives>> such as xref:#asynchronous-primitives-single[Single]. The
xref:#asynchronous-primitives-single[Single] API provides a similar experience to
the `Future`/`Promise` pattern such as
link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html[CompletionStage] and
link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] with
function compoisition.

==== Asynchronous and Streaming
This API paradigm performs I/O asynchronously (e.g. the calling thread is not blocked) and the user can provide/process
the I/O in chunks (as opposed to in a single `Object`). ServiceTalk provides
link:https://www.reactive-streams.org[ReactiveStreams] compatible <<Asynchronous Primitives>> such as
xref:#asynchronous-primitives-publisher[Publisher] to enable this API paradigm.

== Supported JVM
The minimum supported JDK version is 1.8.

== Compatibility
ServiceTalk follows link:https://semver.org/#semantic-versioning-200[SemVer 2.0.0]. API/ABI breaking changes will
require package renaming for that module to avoid runtime classpath conflicts. Note that `0.x.y` releases are not stable
and are permitted to break API/ABI.

== Basic Architecture
=== Blocking Safe By Default
ServiceTalk supports different <<Programming Paradigms, programming models>> for users to work with. However, the
freedom to write blocking code is not just limited to blocking APIs. Users may write blocking code while interacting
with asynchronous APIs as well. Reasons and details about this architecture detail can be found
xref:blocking.adoc[here].

[#asynchronous-primitives]
=== Asynchronous Primitives
ServiceTalk provides link:https://www.reactive-streams.org[ReactiveStreams] compatible <<Asynchronous Primitives>>.

Note that all asynchronous primitives are "lazy"/"cold" in that the action
they represent does not start until someone is "listening" for the results. This is different from "eager"/"hot"
link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] usages in
that the work being done to complete the
link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] is already
happening regardless if anyone is "listening" for the results.

[#asynchronous-primitives-publisher]
==== Publisher
A link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java[Publisher] represents an
asynchronous stream of data. There is a
link:{sourceroot}servicetalk-concurrent/src/main/java/io/servicetalk/concurrent/PublisherSource.java#L59-L102[`PublisherSource.Subscriber<T>`]
that link:{sourceroot}servicetalk-concurrent/src/main/java/io/servicetalk/concurrent/PublisherSource.java#L43[subscribes] and
requests more data via a
link:{sourceroot}servicetalk-concurrent/src/main/java/io/servicetalk/concurrent/PublisherSource.java#L116-L129[PublisherSource.Subscription].

Users are generally not expected to `subscribe` to a `PublisherSource`, or even deal directly with a `PublisherSource`.
Instead, most users are expected to use the
link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java[Publisher] API which provides
many operators to define asynchronous and streaming control flow.

For more details on the API contract please review the
link:https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md#specification[ReactiveStreams Specification].

[#asynchronous-primitives-single]
==== Single
A link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java[Single] shares all the same
semantics as <<Publisher>>, but it either terminates with a
link:{sourceroot}servicetalk-concurrent/src/main/java/io/servicetalk/concurrent/SingleSource.java#L45-L71[single value, or an error].

Users are generally not expected to `subscribe` to a `SingleSource`, or even deal directly with a `SingleSource`.
Instead, most users are expected to use the
link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java[Single] API which provides many
operators to define asynchronous and streaming control flow.

==== Completable
A link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java[Completable] shares all
the same semantics as <<Publisher>>, but it either terminates
link:{sourceroot}servicetalk-concurrent/src/main/java/io/servicetalk/concurrent/CompletableSource.java#L39-63[successfully, or with an error].

Users are generally not expected to `subscribe` to a `CompletableSource`, or even deal directly with a
`CompletableSource`. Instead, most users are expected to use the
link:{sourceroot}servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java[Completable] API which
provides many operators to define asynchronous and streaming control flow.

=== Design Philosophy
ServiceTalk is designed to provide an extensible core and APIs tailored to networking protocols. ServiceTalk does not
intend to provide abstractions for low-level networking primitives (e.g. Channels, EventLoop, TLS, etc...) but instead
uses these primitives to provide a higher level API in numerous <<Programming Paradigms>>.

The project is divided into many modules to decouple the user-facing API from implementation details. This gives users
freedom to choose only the functionality they need, and also allows us to evolve each module independently. Note that
these modules may be divided out into independent repositories to decouple from the core and enable independent
versioning.
