/*
 * Copyright Â© 2019 Apple Inc. and the ServiceTalk project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.servicetalk.grpc.protoc;

import com.google.protobuf.DescriptorProtos.ServiceDescriptorProto;
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse;
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse.File;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;

import static com.squareup.javapoet.MethodSpec.constructorBuilder;
import static io.servicetalk.grpc.protoc.StringUtils.isNotNullNorEmpty;
import static io.servicetalk.grpc.protoc.StringUtils.sanitizeIdentifier;
import static java.util.Objects.requireNonNull;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

final class FileGenerator {
    private static final String GENERATED_BY_COMMENT = "Generated by ServiceTalk proto compiler";

    private final boolean deprecated;
    private final boolean multipleClassFiles;
    private final String fileNameSimple;
    @Nullable
    private final String protoPackageName;
    @Nullable
    private final String javaPackageName;
    @Nullable
    private final String outerClassName;
    private final List<TypeSpec.Builder> serviceClassBuilders;

    FileGenerator(final String fileName, @Nullable final String protoPackageName, final int numServices) {
        this(fileName, protoPackageName, numServices, false, false, null, null);
    }

    FileGenerator(final String fileName, @Nullable final String protoPackageName, final int numServices,
                  final boolean deprecated, final boolean multipleClassFiles, @Nullable final String javaPackageName,
                  @Nullable final String outerClassName) {

        this.fileNameSimple = sanitizeFileName(requireNonNull(fileName));
        this.deprecated = deprecated;
        this.multipleClassFiles = multipleClassFiles;
        this.protoPackageName = protoPackageName;
        this.javaPackageName = javaPackageName;
        this.outerClassName = outerClassName;
        this.serviceClassBuilders = new ArrayList<>(numServices);
    }

    public TypeSpec.Builder newServiceClassBuilder(final ServiceDescriptorProto serviceProto) {
        final TypeSpec.Builder builder = TypeSpec.classBuilder(sanitizeClassName(serviceProto.getName()))
                .addModifiers(PUBLIC, FINAL)
                .addMethod(constructorBuilder()
                        .addModifiers(PRIVATE)
                        .addComment("no instances")
                        .build());

        if (deprecated || serviceProto.hasOptions() && serviceProto.getOptions().hasDeprecated() &&
                serviceProto.getOptions().getDeprecated()) {
            builder.addAnnotation(Deprecated.class);
        }

        serviceClassBuilders.add(builder);
        return builder;
    }

    public void writeTo(final CodeGeneratorResponse.Builder responseBuilder) {
        if (!multipleClassFiles) {
            // All source code should be put into 1 file, use the file that is generated by protoc
            insertFileContent("// " + GENERATED_BY_COMMENT, responseBuilder);
            for (final TypeSpec.Builder builder : serviceClassBuilders) {
                insertFileContent(builder.addModifiers(STATIC).build().toString(), responseBuilder);
            }
            return;
        }

        // write each service to its own file
        final String packageName = javaPackageName();
        for (final TypeSpec.Builder builder : serviceClassBuilders) {
            final TypeSpec serviceType = builder.build();
            final File.Builder fileBuilder = File.newBuilder();
            fileBuilder.setName(calculateFileName(packageName, serviceType.name));

            final JavaFile javaFile = JavaFile.builder(packageName, serviceType)
                    .addFileComment(GENERATED_BY_COMMENT)
                    .build();

            fileBuilder.setContent(javaFile.toString());
            responseBuilder.addFile(fileBuilder.build());
        }
    }

    private void insertFileContent(final String content, final CodeGeneratorResponse.Builder responseBuilder) {
        final File.Builder fileBuilder = File.newBuilder();
        final String className = javaClassName();
        fileBuilder.setName(calculateFileName(javaPackageName(), className));
        fileBuilder.setInsertionPoint("outer_class_scope");
        fileBuilder.setContent(content + "\n");
        responseBuilder.addFile(fileBuilder.build());
    }

    private String javaClassName() {
        return isNotNullNorEmpty(outerClassName) ? sanitizeClassName(outerClassName) : sanitizeClassName(fileNameSimple);
    }

    private String javaPackageName() {
        return isNotNullNorEmpty(javaPackageName) ? javaPackageName :
                isNotNullNorEmpty(protoPackageName) ? protoPackageName : sanitizeClassName(fileNameSimple);
    }

    private static String sanitizeFileName(final String v) {
        int i = v.lastIndexOf('/');
        final int j = v.lastIndexOf('.');
        if (i != -1 && j != -1) {
            if (++i >= v.length()) {
                throw new IllegalArgumentException("Illegal file name: " + v);
            }
            return v.substring(i, j);
        } else if (j != -1) {
            return v.substring(0, j);
        }
        return v;
    }

    private static String sanitizeClassName(final String v) {
        return sanitizeIdentifier(v, false);
    }

    private static String calculateFileName(final String packageName, final String className) {
        return packageName.replace('.', '/') + '/' + className + ".java";
    }
}
