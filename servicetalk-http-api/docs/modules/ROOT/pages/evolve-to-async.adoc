include::ROOT:partial$component-attributes.adoc[]
= Evolving to asynchronous

Blocking programming model is easy to start and understand but it may not be the correct tool for all scenarios.
In fact, ServiceTalk assumes that applications typically have a mixed profile where different parts follow different
xref:servicetalk::introduction.adoc#programming-paradigms[programming paradigms]. One of the goals of ServiceTalk is to
help users evolve from a blocking programming model to a completely asynchronous programming model without the need to
completely rewrite the entire application. This document elaborates how to follow such an evolution.

=== Overview

A mixed profile of application with respect to programming paradigms in essence means that different requests follow
different programming paradigms. ServiceTalk allows such paradigms to co-exist while using the same client/server. In
addition it aims to optimize these interactions by using the correct
xref:blocking.adoc#offloads-in-http[offloading strategy].

=== Design principles

ServiceTalk follows the below principles for providing a path to no offloading:

1. Turning off offloading is always an opt-in.
2. All user code (filters, service, etc) will individually opt-out of offloading when applicable.
3. Explicit opt-in to no offloading by users turns off auto-inference of execution strategy for that entity.
 ServiceTalk will never override that strategy.

=== Asynchronous and offloading

As described xref:servicetalk::blocking.adoc[here], ServiceTalk assumes presence of blocking user code even when
using ServiceTalk's asynchronous APIs. So, in order to eliminate offloading for a request there are __at least__ the
following steps that are required:

1. Make sure that there is no blocking code for processing of a request.
2. Only use asynchronous APIs for processing of a request.
3. Turn off offloading for processing of a request.

(1) is a manual user process and (2) is straightforward, we will elaborate how to achieve (3) for clients and servers.

CAUTION: Remaining sections elaborate how to disable offloading, which is considered an advanced feature.

For (3) ServiceTalk assumes when a user is using any of the above methods, "they know what they are doing" and does not
override that choice.

== Client

For a client, there are two distinct ways of turning off offloading:

1. Disable offloading per request.
2. Disable offloading for the entire client.

For a client which is used for blocking as well as asynchronous programming models requests, (1) is the suggested mode
of operation.

=== No offloads per request

HTTP clients for all programming models provide methods to make requests with or without `HttpExecutionStrategy`.

See
link:{sourceroot}servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClient.java[HttpClient].
[source, java]
----
Single<HttpResponse> request(HttpRequest request);

Single<HttpResponse> request(HttpExecutionStrategy strategy, HttpRequest request);
----

In order to disable offloading for a specific request one has to use a specific `HttpExecutionStrategy` that does not
do any offloading. Such a strategy is available out of the box in
link:{sourceroot}servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpExecutionStrategies.java[HttpExecutionStrategies]
and can be used as below:

[source, java]
----
// Processing of this request does not have any blocking code
httpClient.request(HttpExecutionStrategies.noOffloadsStrategy(), aRequest);
----

For a request made using this strategy, ServiceTalk will not perform any offloading and all user calls may be invoked
on the eventloop.

CAUTION: It is assumed that no blocking code exists during the entire processing of this request. If this assumption
is violated then it will negatively impact the responsiveness of other work done on that eventloop.

=== No offloads per client

If it is certain that no blocking requests will be made using a client without explicitly overriding the strategy,
then one can disable offloading for the entire client using the following option on the client builder.

See
link:{sourceroot}servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java[HttpClientBuilder].
[source,java]
----
clientBuilder.executionStrategy(HttpExecutionStrategies.noOffloadsStrategy());
----

This strategy will be used for all requests that do not explicitly specify a strategy.

CAUTION: Beware of inadvertently adding a request which uses blocking code to a client that has offloading disabled.

== Server

ServiceTalk core is unaware of a routing technology and assumes that routing is implemented inside the service provided
to the server. This enables us to provide vastly different routing solutions without changing the core of ServiceTalk.
However, it does mean that ServiceTalk only knows the programming model of the service that implements routing and not
the programming model of the routes for each request. Since, ServiceTalk has to select an execution strategy before
invoking the service (router) this means that an individual route can not entirely control all offloading done by the
server. Hence, all routers in ServiceTalk have two execution strategies in play for any request processing:

1. _Strategy for the server_: All code that constitutes request processing in a server apart from the actual route.
2. _Strategy for a route_: Route implementation for a particular request.

=== Server Strategy

Execution strategy for a server can be specified on the server builder just like the client. In order to disable
offloading for the entire server, the following option can be used:

See
link:{sourceroot}servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java[HttpServerBuilder].
[source,java]
----
serverBuilder.executionStrategy(HttpExecutionStrategies.noOffloadsStrategy());
----

This strategy will be used for all requests processed by this server.

CAUTION: Beware of inadvertently adding blocking code to a server that has offloading disabled.

=== Route strategy

Each route added to any router may define an independent execution strategy which is used to invoke that route.
Different routers may provide different ways of specifying that strategy, however, conceptually there are two ways to
specify such a strategy:

==== Implicit route strategy

A router may have the ability to infer an appropriate execution strategy for a route from the programming model the route
uses, just like ServiceTalk xref:blocking.adoc#programming-models[infers execution strategy per programming model].
This auto-inference is only used if no strategy is explicitly specified for that route.

==== Explicit route strategy

A router may also provide a capability for a route to explicitly define an execution strategy that is used to invoke
that route. In presence of such an explicit strategy, auto-inference of the route strategy is disabled. In order to
disable offloads, one should use
link:{sourceroot}servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpExecutionStrategies.java[`HttpExecutionStrategies.noOffloadsStrategy()`]

==== Recommended approach

In order to effectively evolve to different programming models, one should ensure that each route defines its own
strategy either implicitly (when supported by the router) or explicitly (for overrides or lack of implicit strategy
capabilities in the router). Depending on server strategy for a route is dangerous because:

1. Server strategy may change, adversely impacting the route.
2. Increasing scope of server strategy (to also be the default strategy for all routes) makes it hard to understand how
changing that strategy may impact all routes. Typically, server strategy should be chosen based on all code that is
executed before executing the actual route for a request.

Making sure that all routes can independently specify their strategy makes it easier to reason about the impacts of
changing these strategies. ServiceTalk provided routers provide ways to explicitly specify a route strategy, implicit
inference capabilities may vary. See xref:servicetalk-http-router-jersey::evolve-to-async.adoc[Jersey Router]
to see its capabilities for per route strategies.
