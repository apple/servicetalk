// Configure {source-root} values based on how this document is rendered: on GitHub or not
ifdef::env-github[]
:source-root:
endif::[]
ifndef::env-github[]
ifndef::source-root[:source-root: https://github.com/apple/servicetalk/blob/{page-origin-refname}]
endif::[]

= Blocking safe by default (Implementation Details)

As described in the section
xref:{page-version}@servicetalk-concurrent-api::blocking-safe-by-default.adoc[Blocking Safe By Default],
ServiceTalk, by default, allows users to write blocking code when interacting with ServiceTalk. This document describes
the details of the implementation and is addressed to audiences who intend to know the internals of how this is achieved.

NOTE: It is not required to read this document if you just want to use ServiceTalk.

== Asynchronous Sources

Everything inside ServiceTalk is somehow connected to one of the three asynchronous sources, viz., `Publisher`, `Single`
and `Completable`. Since these sources are the building blocks for program control flow if they provide safety
guarantees for blocking code execution these guarantees apply outside the scope of preventing blocking code from
executing on event loop thread. This approach is designed to make the task of ensuring we don't block the event loop
threads less error-prone, and also allows for certain optimizations around thread context propagation and re-use.

== Threads and asynchronous sources

An asynchronous source has two important decisions to make about thread usage:

1. Which thread or executor will be used to do the actual task related to a source. eg: for an HTTP client, the task
is to send an HTTP request and read the HTTP response.
2. Which thread or executor will be used to interact with the `Subscriber` corresponding to its `Subscription`s.

Part 1. above is not governed by the
link:https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification[ReactiveStreams specification]
and hence sources are free to use any thread. ServiceTalk typically will use Netty's `EventLoop` to perform the actual
task.

Part 2. defines all the interactions using the ReactiveStreams specifications, i.e. all methods in `Publisher`,
`Subscriber` and `Subscription`. The ReactiveStreams specification requires that signals are not delivered
link:https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.3[concurrently],
but doesn't have any restrictions about which threads are used. This means the same thread maybe used for all signal
deliveries for a given Subscriber, but it is also valid to use any thread (as long as no concurrency is introduced).
ServiceTalk concurrency APIs are used to define which executor will be used for an asynchronous source for Part 2.,
which is typically an application `Executor`.

== Offloading and asynchronous sources

ServiceTalk uses the `link:{source-root}/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Executor.java[Executor]`
abstraction to specify the source of threads to be used for the delivery of signals from an asynchronous source. The
default signal offloading, if any, used by an asynchronous source is determined by the source. For example, the HTTP
sources, in addition to allowing for specification of an offloading executor, provide both direct control of the
offloading via
`xref:{page-version}@servicetalk-concurrent-api::blocking-safe-by-default.adoc#execution-strategy[ExecutionStrategy]`
and may also influenced by the
xref:{page-version}@servicetalk-concurrent-api::blocking-safe-by-default.adoc#influencing-offloading-decisions[computed execution strategy].

Applications with asynchronous, blocking or computationally expensive tasks can also offload those tasks to specific
`Executor`. The `subscribeOn(Executor)` and `publishOn(Executor)` operators will cause offloading execution from the
default signal delivery thread to a thread from the provided `Executor`. The below diagram illustrates the interaction
between an asynchronous source, its `Subscriber`, its operators, and the `Executor`.

image::offloading.svg[Offloading]

During `subscribe()` the execution will offload at the `subscribeOn()` operator and transition execution from the
application thread to an `Exeuctor` thread. The application thread will be able to continue while the subscribe
operation asynchronously continues on an `Executor` thread.

When a result is available at the source it will begin publication using the receiving event loop thread but will
offload at the `publishOn()` operator and transition execution from the event loop thread to an `Executor` thread. Once
the publish signal is offloaded the event loop thread will be available again for executing other I/O tasks while the
response is asynchronously processed on the `Executor` thread.

=== `publishOn()` Example

Using the `publishOn(executor)` operator allows processing of signals related to the source content on a different
thread than is generating (or receiving) the content. It is the most common form of offloading used.

[source, java]
----
Collection<Integer> result = Publisher.range(1, 10) <2> <5>
        .map(element -> element)  // non-offloaded NO-OP
        .publishOn(publishExecutor)  <4>
        .map(element -> element)  // offloaded NO-OP
        .toFuture()  <3>
        .get();  <1> <6>
----

<1> `toFuture().get` begins by calling `subscribe(Subscriber)`. Executing on the application thread, execution flows up
the operator chain towards the source; `map` -> `publishOn` -> `map` -> `Publisher.range(1, 10)`.

<2> Still executing on the application thread, `Range` will call `Subscriber.onSubscribe(Subscription)` on the
`Subscriber`. This flows back down the operator chain, `Range` -> `map` -> `publishOn` -> `map` -> `toFuture`.

<3> When `subscribe()` is complete, `toFuture()` will call `Subscription.request(Long.MAX_VALUE)`. This will cause
`Range` to publish synchronously via `onNext(element)` nine items, the integers "`1`" through "`9`".

<4> Each `onNext` flows down the operator chain, `Range` -> `map` -> `publishOn` (offloads on to `publishExecutor`
thread) -> `map` -> `toFuture` where the element is collected for the result. For each offloaded item a thread of
`publishExecutor` will be used for executing the second `map` operator and final collect operation.

<5> The application thread will continue to publish all the elements from the source and will finally send the
`onComplete()` signal. This signal will also be offloaded to the `publisherExecutor` and will complete the `Future` with
the integer collection result.

<6> The application thread will wait at `get()` for the `Future` result to be asynchronously completed.

=== `subscribeOn()` Example

Using the `subscribeOn(executor)` operator allows processing of the subscription and demand. Using the
`subscribeOn(executor)` operator generally requires an understanding of the behavior of the source; using a different
source may change the need for offloading.

[source, java]
----
Collection<Integer> result = Publisher.range(1, 10) <2> <4>
        .map(element -> element)  // NO-OP
        .subscribeOn(subscribeExecutor)
        .toFuture() <3>
        .get(); <1>
----

<1> `toFuture().get()` will do a `subscribe(Subscriber)`. This flows up the operator chain toward the source;
`subscribeOn` (offload onto `subscribeExecutor` thread) -> `map` -> `Range`.

<2> `Range` will call `Subscriber.onSubscribe(Subscription)` on the `Subscriber`. This flows back down the operator
chain, `Range` -> `map` -> `subscribeOn` -> `toFuture`.

<3> `toFuture()` will call `Subscription.request(Long.MAX_VALUE)`. This flows up the operator chain, `subscribeOn`
(offloads onto `subscribeExecutor`  thread) -> `map` -> `Range`.

<4> Still on a thread from `subscribeExecutor`, `Range` ` will publish synchronously via `onNext(element)` nine items,
the integers "`1`" through "`9`" (on a thread from ). Each `onNext` flows back down the operator chain, `Range` -> `map`
-> `subscribeOn` -> `toFuture` when the element is collected for the result.

=== publishOn()/subscribeOn() Detailed Example

These examples can be expanded to demonstrate the offloading behavior directly. The expanded example extends the NO-OP
`map` implementations to reveal the active thread during their execution. To show the active thread at the other
points described in the callouts the expanded example also adds `whenOnSubscribe`, `whenRequest`, `liftSync` and
`whenFinally` operations in the operator chain. The output of the example shows the thread used for executing each of
the operators, while the specialized operators provide examples of how you might use them to debug your own programs.

[source, java]
----
Collection<?> result = Publisher.range(1, 3)
        .map(element -> {
            System.out.println("\nPublish starts on " + Thread.currentThread() + " Received : " + element);
            return element;
        })
        .whenOnSubscribe(subscription -> {
            System.out.println("\nonSubscribe starts on " + Thread.currentThread());
        })
        .publishOn(publishExecutor)
        .map(element -> {
            System.out.println("\nPublish offloaded to " + Thread.currentThread() + " Received : " + element);
            return element;
        })
        .whenRequest(request -> {
            System.out.println("\nrequest(" + request + ") offloaded to " + Thread.currentThread());
        })
        .liftSync(subscriber -> {
            System.out.println("\nSubscribe offloaded to " + Thread.currentThread());
            return subscriber;
        })
        .subscribeOn(subscribeExecutor)
        .liftSync(subscriber -> {
            System.out.println("\nSubscribe begins on " + Thread.currentThread());
            return subscriber;
        })
        .whenOnSubscribe(subscription -> {
            System.out.println("\nonSubscribe offloaded to " + Thread.currentThread());
        })
        .whenRequest(request -> {
            System.out.println("\nrequest(" + request + ") starts on " + Thread.currentThread());
        })
        .whenFinally(new TerminalSignalConsumer() {
            @Override
            public void onComplete() {
                        System.out.println("\ncomplete on " + Thread.currentThread());
                    }

            @Override
            public void onError(final Throwable throwable) {
                System.out.println("\nerror (" + throwable + ") on " + Thread.currentThread());
            }

            @Override
                public void cancel() {
                        System.out.println("\ncancel on " + Thread.currentThread());
                    }
        })
        .toFuture()
        .get();
----
