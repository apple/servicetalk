<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Single</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Single";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":9,"i9":9,"i10":10,"i11":9,"i12":9,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":10,"i30":10,"i31":10,"i32":9,"i33":9,"i34":10,"i35":10,"i36":10,"i37":9,"i38":9,"i39":9,"i40":9,"i41":6,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":9,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":9,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.servicetalk.concurrent.api</a></div>
<h2 title="Class Single" class="title">Class Single&lt;T&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.servicetalk.concurrent.api.Single&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the single.</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="LegacyTestSingle.html" title="class in io.servicetalk.concurrent.api">LegacyTestSingle</a></code>, <code><a href="internal/SubscribableSingle.html" title="class in io.servicetalk.concurrent.api.internal">SubscribableSingle</a></code>, <code><a href="TestSingle.html" title="class in io.servicetalk.concurrent.api">TestSingle</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">Single&lt;T&gt;</span>
extends java.lang.Object</pre>
<div class="block">An asynchronous computation that either completes with success giving the result or completes with an error.

 <h2>How to subscribe?</h2>

 This class does not provide a way to subscribe using a <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> as such calls are
 ambiguous about the intent whether the subscribe is part of the same source (a.k.a an operator) or it is a terminal
 subscribe. If it is required to subscribe to a source, then a <a href="SourceAdapters.html" title="class in io.servicetalk.concurrent.api"><code>source adapter</code></a> can be used to
 convert to a <a href="../SingleSource.html" title="interface in io.servicetalk.concurrent"><code>SingleSource</code></a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colSecond" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Single</a></span>()</code></th>
<td class="colLast">
<div class="block">New instance.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterCancel(java.lang.Runnable)">afterCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(java.lang.Runnable)">afterFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnError(java.util.function.Consumer)">afterOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSubscribe(java.util.function.Consumer)">afterOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSuccess(java.util.function.Consumer)">afterOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterSubscriber(java.util.function.Supplier)">afterSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(io.servicetalk.concurrent.api.Single...)">amb</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(java.lang.Iterable)">amb</a></span>&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ambWith(io.servicetalk.concurrent.api.Single)">ambWith</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(io.servicetalk.concurrent.api.Single...)">anyOf</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(java.lang.Iterable)">anyOf</a></span>&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeCancel(java.lang.Runnable)">beforeCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(java.lang.Runnable)">beforeFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnError(java.util.function.Consumer)">beforeOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSubscribe(java.util.function.Consumer)">beforeOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSuccess(java.util.function.Consumer)">beforeOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeSubscriber(java.util.function.Supplier)">beforeSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)">collectUnordered</a></span>&#8203;(int&nbsp;maxConcurrency,
                <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(io.servicetalk.concurrent.api.Single...)">collectUnordered</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(java.lang.Iterable)">collectUnordered</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnordered(java.lang.Iterable,int)">collectUnordered</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)">collectUnorderedDelayError</a></span>&#8203;(int&nbsp;maxConcurrency,
                          <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)">collectUnorderedDelayError</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(java.lang.Iterable)">collectUnorderedDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectUnorderedDelayError(java.lang.Iterable,int)">collectUnorderedDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                          int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Completable)">concat</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Publisher)">concat</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Single)">concat</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defer(java.util.function.Supplier)">defer</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singleSupplier)</code></th>
<td class="colLast">
<div class="block">Defer creation of a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> till it is subscribed to.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes with the provided error <code>cause</code>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMap(java.util.function.Function)">flatMap</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that mirrors emissions from the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapCompletable(java.util.function.Function)">flatMapCompletable</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors emissions from the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapPublisher(java.util.function.Function)">flatMapPublisher</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that mirrors emissions from the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code>.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromCallable(java.util.concurrent.Callable)">fromCallable</a></span>&#8203;(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Callable.call()</code> on the passed
 <code>Callable</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFuture(java.util.concurrent.Future)">fromFuture</a></span>&#8203;(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>Future</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> via <code>Future.get()</code>.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromStage(java.util.concurrent.CompletionStage)">fromStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;? extends T&gt;&nbsp;stage)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromSupplier(java.util.function.Supplier)">fromSupplier</a></span>&#8203;(java.util.function.Supplier&lt;T&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Supplier.get()</code> on the passed
 <code>Supplier</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)">handleSubscribe</a></span>&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">Handles a subscriber to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(long,java.util.concurrent.TimeUnit)">idleTimeout</a></span>&#8203;(long&nbsp;duration,
           java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">idleTimeout</a></span>&#8203;(long&nbsp;duration,
           java.util.concurrent.TimeUnit&nbsp;unit,
           <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(java.time.Duration)">idleTimeout</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(java.time.Duration,io.servicetalk.concurrent.Executor)">idleTimeout</a></span>&#8203;(java.time.Duration&nbsp;duration,
           <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ignoreElement()">ignoreElement</a></span>()</code></th>
<td class="colLast">
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)">liftAsync</a></span>&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftSync(io.servicetalk.concurrent.api.SingleOperator)">liftSync</a></span>&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#map(java.util.function.Function)">map</a></span>&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Maps the result of this single to a different type.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that never terminates.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)">publishAndSubscribeOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 
     All <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)">publishAndSubscribeOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 
     All <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.api.Executor)">publishOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOnOverride(io.servicetalk.concurrent.api.Executor)">publishOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recoverWith(java.util.function.Function)">recoverWith</a></span>&#8203;(java.util.function.Function&lt;java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the
 passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(java.util.function.IntPredicate)">repeat</a></span>&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the passed <code>IntPredicate</code> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeatWhen(java.util.function.IntFunction)">repeatWhen</a></span>&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(io.servicetalk.concurrent.api.BiIntPredicate)">retry</a></span>&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">retryWhen</a></span>&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribe(java.util.function.Consumer)">subscribe</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;resultConsumer)</code></th>
<td class="colLast">
<div class="block">Subscribe to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, emits the result to the passed <code>Consumer</code> and log any
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeInternal(io.servicetalk.concurrent.SingleSource.Subscriber)">subscribeInternal</a></span>&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">A internal subscribe method similar to <a href="../SingleSource.html#subscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>SingleSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)">subscribeOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOnOverride(io.servicetalk.concurrent.api.Executor)">subscribeOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.
 
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeShareContext()">subscribeShareContext</a></span>()</code></th>
<td class="colLast">
<div class="block">Signifies that when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="AsyncContextMap.html#copy()"><code>copy</code></a>.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#succeeded(T)">succeeded</a></span>&#8203;(T&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes successfully with the provided <code>value</code>.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletable()">toCompletable</a></span>()</code></th>
<td class="colLast">
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletionStage()">toCompletionStage</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>CompletionStage</code>.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFuture()">toFuture</a></span>()</code></th>
<td class="colLast">
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>Future</code>.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toPublisher()">toPublisher</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Single</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenCancel(java.lang.Runnable)">whenCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(java.lang.Runnable)">whenFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 
     <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>
     <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnError(java.util.function.Consumer)">whenOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSubscribe(java.util.function.Consumer)">whenOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSuccess(java.util.function.Consumer)">whenOnSuccess</a></span>&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenSubscriber(java.util.function.Supplier)">whenSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of
 the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Single</h4>
<pre>protected&nbsp;Single()</pre>
<div class="block">New instance.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="map(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;map&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;mapper)</pre>
<div class="block">Maps the result of this single to a different type. Error, if any is forwarded to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     R rResult = mapper.apply(tResult);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the returned <code>Single</code>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - To convert this result to other.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will now have the result of type <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="recoverWith(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverWith</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;recoverWith&#8203;(java.util.function.Function&lt;java.lang.Throwable,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> by using another <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the
 passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     T result;
     try {
         result = resultOfThisSingle();
     } catch (Throwable cause) {
         // Note that nextFactory returning a error Single is like re-throwing (nextFactory shouldn't throw).
         result = nextFactory.apply(cause);
     }
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextFactory</code> - Returns the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, when this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that recovers from an error from this <code>Single</code> by using another
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> provided by the passed <code>nextFactory</code>.</dd>
</dl>
</li>
</ul>
<a id="flatMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;flatMap&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends R&gt;&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that mirrors emissions from the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     R rResult = mapper.apply(tResult); // Asynchronous result is flatten into a value by this operator.
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the result of the resulting <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that switches to the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returned by <code>next</code> after this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 completes successfully.</dd>
</dl>
</li>
</ul>
<a id="flatMapCompletable(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;flatMapCompletable&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors emissions from the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous with either complete/error status
 in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     mapper.apply(tResult); // Asynchronous result is flatten into a error or completion by this operator.
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that switches to the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>next</code> after this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully.</dd>
</dl>
</li>
</ul>
<a id="flatMapPublisher(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapPublisher</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;R&gt;&nbsp;flatMapPublisher&#8203;(java.util.function.Function&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends <a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends R&gt;&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that mirrors emissions from the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code>.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method is similar to <a href="#map(java.util.function.Function)"><code>map(Function)</code></a> but the result is asynchronous, and provides a data
 transformation in sequential programming similar to:
 <pre><code>
     T tResult = resultOfThisSingle();
     // Asynchronous result from mapper is flatten into collection of values.
     for (R rResult : mapper.apply(tResult)) {
          // process rResult
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of objects emitted by the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - Function to give the next <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that switches to the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> returned by <code>next</code> after this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> completes successfully.</dd>
</dl>
</li>
</ul>
<a id="whenOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>onSuccess</code> will be invoked relative to <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnSuccess(java.util.function.Consumer)"><code>beforeOnSuccess(Consumer)</code></a> and
 <a href="#afterOnSuccess(java.util.function.Consumer)"><code>afterOnSuccess(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(result);
  onSuccess.accept(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked when <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnSuccess(java.util.function.Consumer)"><code>beforeOnSuccess(Consumer)</code></a>, 
<a href="#afterOnSuccess(java.util.function.Consumer)"><code>afterOnSuccess(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>onError</code> will be invoked relative to <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a> and
 <a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked when <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a>, 
<a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a> and <a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked exactly once, when any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a>, 
<a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument when any
 of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>beforeFinally(SingleTerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>afterFinally(SingleTerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onSuccess(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>beforeFinally(SingleTerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)"><code>afterFinally(SingleTerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is undefined. If
 you need strict ordering see <a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a> and <a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a>, 
<a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;idleTimeout&#8203;(long&nbsp;duration,
                                   java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;idleTimeout&#8203;(long&nbsp;duration,
                                   java.util.concurrent.TimeUnit&nbsp;unit,
                                   <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;idleTimeout&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and
 termination. The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will via <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;idleTimeout&#8203;(java.time.Duration&nbsp;duration,
                                   <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> will be
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will mimic the signals of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> but will terminate with a
 <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     Pair&lt;T, T&gt; p = new Pair&lt;&gt;();
     p.first = resultOfThisSingle();
     p.second = nextSingle();
     return p;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</pre>
<div class="block">Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.
 <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will only be subscribed to after this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> terminates successfully.
 Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is forwarded to the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     T result = resultOfThisSingle();
     nextCompletable(); // Note this either completes successfully, or throws an error.
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> after <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 terminates successfully.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;concat&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;next)</pre>
<div class="block">Returns a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits all
 elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any error emitted by this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or <code>next</code>
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> is forwarded to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     results.add(resultOfThisSingle());
     results.addAll(nextStream());
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to concat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>New <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that first emits the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and then subscribes and emits
 all elements from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
</dl>
</li>
</ul>
<a id="retry(io.servicetalk.concurrent.api.BiIntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;retry&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.
 <p>
 This method provides a means to retry an operation under certain failure conditions and in sequential programming
 is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             return resultOfThisSingle();
         } catch (Throwable cause) {
             if (shouldRetry.apply(attempts + 1, cause)) {
                 return execute(attempts + 1);
             } else {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRetry</code> - <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> that given the retry count and the most recent <code>Throwable</code>
 emitted from this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> determines if the operation should be retried.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or re-subscribes if an error is emitted
 and if the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returned <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retryWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;retryWhen&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> terminates with that error.
 <p>
 This method provides a means to retry an operation under certain failure conditions in an asynchronous fashion
 and in sequential programming is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             return resultOfThisSingle();
         } catch (Throwable cause) {
             try {
                 shouldRetry.apply(attempts + 1, cause); // Either throws or completes normally
                 execute(attempts + 1);
             } catch (Throwable ignored) {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>retryWhen</code> - <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> that given the retry count and the most recent <code>Throwable</code> emitted
 from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, that error is
 emitted from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, otherwise, original <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is re-subscribed when this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or re-subscribes if an error is emitted
 and <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeat(java.util.function.IntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;repeat&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the passed <code>IntPredicate</code> returns <code>true</code>.
 <p>
 This method provides a means to repeat an operation multiple times and in sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     do {
         results.add(resultOfThisSingle());
     } while (shouldRepeat.test(++i));
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRepeat</code> - <code>IntPredicate</code> that given the repeat count determines if the operation should be
 repeated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and from all re-subscriptions whenever
 the operation is repeated.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX repeat operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeatWhen(java.util.function.IntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;repeatWhen&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</pre>
<div class="block">Re-subscribes to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> emits an error.
 <p>
 This method provides a means to repeat an operation multiple times when in an asynchronous fashion and in
 sequential programming is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     int i = 0;
     while (true) {
         results.add(resultOfThisSingle());
         try {
             repeatWhen.apply(++i); // Either throws or completes normally
         } catch (Throwable cause) {
             break;
         }
     }
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>repeatWhen</code> - <code>IntFunction</code> that given the repeat count returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error repeat is terminated, otherwise, original <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 re-subscribed when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and from all re-subscriptions whenever
 the operation is repeated.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  onSuccess.accept(result);
  nextOperation(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      onError.accept(cause);
      nextOperation(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>before</strong> <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      doFinally.run();
      nextOperation(); // Maybe notifying of cancellation, or termination
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onComplete();
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onSuccess(result);
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;beforeSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.

 <p>
 The order in which <code>onSubscribe</code> will be invoked relative to
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is undefined. If you need strict ordering see
 <a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a> and <a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked when <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a>, 
<a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="afterOnSuccess(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSuccess</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnSuccess&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;onSuccess)</pre>
<div class="block">Invokes the <code>onSuccess</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result = resultOfThisSingle();
  nextOperation(result);
  onSuccess.accept(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSuccess</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    T result = resultOfThisSingle();
  } catch (Throwable cause) {
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>after</strong> <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      T result = resultOfThisSingle();
  } finally {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.SingleTerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterFinally&#8203;(<a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">SingleTerminalSignalConsumer</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../SingleSource.Subscriber.html#onSuccess(T)"><code>SingleSource.Subscriber.onSuccess(Object)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onSuccess(T)"><code>SingleTerminalSignalConsumer.onSuccess(Object)</code></a></li>
     <li><a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a> - invokes
     <a href="SingleTerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>SingleTerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="SingleTerminalSignalConsumer.html#cancel()"><code>SingleTerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  T result;
  try {
      result = resultOfThisSingle();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onSuccess(result);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, at most one method of this
 <a href="SingleTerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>SingleTerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;afterSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to subscribe and
 invokes all the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;whenSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of
 the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> for each new subscribe and invokes methods on that
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> when the corresponding methods are called for <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>s of the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#publishOnOverride(io.servicetalk.concurrent.api.Executor)"><code>publishOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods on the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOnOverride</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for
 invoking all <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods. If such an override is not required, <a href="#publishOn(io.servicetalk.concurrent.api.Executor)"><code>publishOn(Executor)</code></a> can be
 used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> both for the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> as well as <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscribeOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#subscribeOnOverride(io.servicetalk.concurrent.api.Executor)"><code>subscribeOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOnOverride</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscribeOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> for
 invoking the above specified methods.
 If such an override is not required, <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> both for the returned
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> as well as <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishAndSubscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishAndSubscribeOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</li>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishAndSubscribeOnOverride</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;publishAndSubscribeOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> methods.</li>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> method.</li>
 </ul>
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>.
 If such an override is not required, <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>handleSubscribe(SingleSource.Subscriber)</code></a> both for the
 returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> as well as <code>this</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeShareContext()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeShareContext</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscribeShareContext()</pre>
<div class="block">Signifies that when the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="AsyncContextMap.html#copy()"><code>copy</code></a>.
 <p>
 This operator only impacts behavior if the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is subscribed directly after this operator,
 that means this must be the "last operator" in the chain for this to have an impact.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that will share the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> instead of making a
 <a href="AsyncContextMap.html#copy()"><code>copy</code></a> when subscribed to.</dd>
</dl>
</li>
</ul>
<a id="liftSync(io.servicetalk.concurrent.api.SingleOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftSync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;liftSync&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which will wrap the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> using the provided <code>operator</code>
 argument before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <pre><code>
     Single&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftSync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" <strong>MUST</strong> be "synchronous" in that it does not interact
 with the original <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> from outside the modified <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a>
 threads. That is to say this operator will not impact the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> constraints already in place between
 <i>A</i> and <i>B</i> above. If you need asynchronous behavior, or are unsure, see
 <a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftAsync(SingleOperator)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and the return is the "modified" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftAsync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftAsync(SingleOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="liftAsync(io.servicetalk.concurrent.api.SingleOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftAsync</h4>
<pre class="methodSignature">public final&nbsp;&lt;R&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;R&gt;&nbsp;liftAsync&#8203;(<a href="SingleOperator.html" title="interface in io.servicetalk.concurrent.api">SingleOperator</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>,&#8203;? extends R&gt;&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which will wrap the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> using the provided <code>operator</code>
 argument before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // Aw
        .liftAsync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" MAY be "asynchronous" in that it may interact with the original
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> from outside the modified <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> threads. More
 specifically:
 <ul>
  <li>all of the <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> invocations going "downstream" (i.e. from <i>A</i> to <i>B</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
  <li>all of the <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> invocations going "upstream" (i.e. from <i>B</i> to <i>A</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
 </ul>
 This behavior exists to prevent blocking code negatively impacting the thread that powers the upstream source of
 data (e.g. an EventLoop).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - Type of the items emitted by the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and the return is the "modified" <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> before subscribing to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftSync(io.servicetalk.concurrent.api.SingleOperator)"><code>liftSync(SingleOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="ambWith(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ambWith</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;ambWith&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;other)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from either of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> with which the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of either this
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> or the passed <code>other</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, whichever terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="toPublisher()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toPublisher</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toPublisher()</pre>
<div class="block">Converts this <code>Single</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits at most a single item which is emitted by this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="toCompletable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletable</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;toCompletable()</pre>
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="ignoreElement()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreElement</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;ignoreElement()</pre>
<div class="block">Ignores the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> and forwards the termination signal to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that mirrors the terminal signal from this <code>Single</code>.</dd>
</dl>
</li>
</ul>
<a id="toCompletionStage()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletionStage</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.CompletionStage&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toCompletionStage()</pre>
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>CompletionStage</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>CompletionStage</code> that mirrors the terminal signal from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="toFuture()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFuture</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.Future&lt;<a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;toFuture()</pre>
<div class="block">Convert this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to a <code>Future</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that mirrors the terminal signal from this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeInternal(io.servicetalk.concurrent.SingleSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeInternal</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;subscribeInternal&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">A internal subscribe method similar to <a href="../SingleSource.html#subscribe(io.servicetalk.concurrent.SingleSource.Subscriber)"><code>SingleSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a> to subscribe for the result.</dd>
</dl>
</li>
</ul>
<a id="subscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&nbsp;subscribe&#8203;(java.util.function.Consumer&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;resultConsumer)</pre>
<div class="block">Subscribe to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, emits the result to the passed <code>Consumer</code> and log any
 <a href="../SingleSource.Subscriber.html#onError(java.lang.Throwable)"><code>SingleSource.Subscriber.onError(Throwable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultConsumer</code> - <code>Consumer</code> to accept the result of this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> used to invoke <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> on the parameter of
 <a href="../SingleSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>SingleSource.Subscriber.onSubscribe(Cancellable)</code></a> for this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="handleSubscribe(io.servicetalk.concurrent.SingleSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleSubscribe</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;handleSubscribe&#8203;(<a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent">SingleSource.Subscriber</a>&lt;? super <a href="Single.html" title="type parameter in Single">T</a>&gt;&nbsp;subscriber)</pre>
<div class="block">Handles a subscriber to this <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - the subscriber.</dd>
</dl>
</li>
</ul>
<a id="succeeded(java.lang.Object)">
<!--   -->
</a><a id="succeeded(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>succeeded</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;succeeded&#8203;(@Nullable
                                      T&nbsp;value)</pre>
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes successfully with the provided <code>value</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromCallable(java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromCallable</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromCallable&#8203;(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Callable.call()</code> on the passed
 <code>Callable</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error
 emitted by the <code>Callable</code> will terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> with the same error.
 <p>
 Blocking inside <code>Callable.call()</code> will in turn block the subscribe call to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. If
 this behavior is undesirable then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> should be offloaded using one of the operators that
 offloads the subscribe call (eg: <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a>, <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callable</code> - <code>Callable</code> which supplies the result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromSupplier(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSupplier</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromSupplier&#8203;(java.util.function.Supplier&lt;T&gt;&nbsp;supplier)</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which when subscribed will invoke <code>Supplier.get()</code> on the passed
 <code>Supplier</code> and emit the value returned by that invocation from the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error
 emitted by the <code>Supplier</code> will terminate the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> with the same error.
 <p>
 Blocking inside <code>Supplier.get()</code> will in turn block the subscribe call to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. If
 this behavior is undesirable then the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> should be offloaded using one of the operators that
 offloads the subscribe call (eg: <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a>, <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>supplier</code> - <code>Supplier</code> which supplies the result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Creates a realized <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> which always completes with the provided error <code>cause</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cause</code> - result of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;never()</pre>
<div class="block">Creates a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that never terminates.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
</dl>
</li>
</ul>
<a id="defer(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defer</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;defer&#8203;(java.util.function.Supplier&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singleSupplier)</pre>
<div class="block">Defer creation of a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> till it is subscribed to.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singleSupplier</code> - <code>Supplier</code> to create a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> every time the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> is
 subscribed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> using <code>singleSupplier</code> every time
 it is subscribed and forwards all items and terminal events from the newly created <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to its
 <a href="../SingleSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>SingleSource.Subscriber</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromFuture(java.util.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromFuture&#8203;(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</pre>
<div class="block">Convert from a <code>Future</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> via <code>Future.get()</code>.
 <p>
 Note that because <code>Future</code> only presents blocking APIs to extract the result, so the process of getting the
 results will block. The caller of subscribe is responsible for offloading if necessary, and also offloading if
 <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> will be called and this operation may block.
 <p>
 To apply a timeout see <a href="#idleTimeout(long,java.util.concurrent.TimeUnit)"><code>idleTimeout(long, TimeUnit)</code></a> and related methods.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The data type the <code>Future</code> provides when complete.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>future</code> - The <code>Future</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that derives results from <code>Future</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#idleTimeout(long,java.util.concurrent.TimeUnit)"><code>idleTimeout(long, TimeUnit)</code></a></dd>
</dl>
</li>
</ul>
<a id="collectUnordered(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(java.lang.Iterable)"><code>collectUnorderedDelayError(Iterable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(int, Single[])</code></a> should be used. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)"><code>collectUnorderedDelayError(Single[])</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                                                                   int&nbsp;maxConcurrency)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(java.lang.Iterable,int)"><code>collectUnorderedDelayError(Iterable, int)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnordered(int,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnordered</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnordered&#8203;(int&nbsp;maxConcurrency,
                                                                   <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will immediately terminate with
 that error. In such a case, any in progress <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s will be cancelled. In order to delay error
 termination use <a href="#collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnorderedDelayError(int, Single[])</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          result.add(ft.get());
      }
      return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnorderedDelayError(java.lang.Iterable,int)"><code>collectUnorderedDelayError(Iterable, int)</code></a>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable)"><code>collectUnordered(Iterable)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#collectUnordered(int,io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(int, Single[])</code></a>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(io.servicetalk.concurrent.api.Single...)"><code>collectUnordered(Single[])</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
              // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles,
                                                                             int&nbsp;maxConcurrency)</pre>
<div class="block">Asynchronously collects results of individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s returned by the passed <code>Iterable</code> into a
 single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <code>Iterable</code> of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="collectUnorderedDelayError(int,io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectUnorderedDelayError</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.util.Collection&lt;T&gt;&gt;&nbsp;collectUnorderedDelayError&#8203;(int&nbsp;maxConcurrency,
                                                                             <a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Asynchronously collects results of the passed <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s into a single <code>Collection</code>. <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#collectUnordered(java.lang.Iterable,int)"><code>collectUnordered(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;T&gt; result = ...;// assume this is thread safe
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
             // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                result.add(ft.get());
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return rResults;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s that will be active at any point in time.</dd>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> producing a <code>Collection</code> of all values produced by the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s.
 There is no guarantee of the order of the values in the produced <code>Collection</code> as compared to the order of
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s passed to this method.</dd>
</dl>
</li>
</ul>
<a id="fromStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromStage</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;fromStage&#8203;(java.util.concurrent.CompletionStage&lt;? extends T&gt;&nbsp;stage)</pre>
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 A best effort is made to propagate <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> to the <code>CompletionStage</code>. Cancellation for
 <code>CompletionStage</code> implementations will result in exceptional completion and invoke user
 callbacks. If there is any blocking code involved in the cancellation process (including invoking user callbacks)
 you should investigate if using an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> is appropriate.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The data type the <code>CompletionStage</code> provides when complete.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stage</code> - The <code>CompletionStage</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that derives results from <code>CompletionStage</code>.</dd>
</dl>
</li>
</ul>
<a id="amb(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;amb&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="amb(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;amb&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(io.servicetalk.concurrent.api.Single...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;anyOf&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;...&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;anyOf&#8203;(java.lang.Iterable&lt;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&gt;&nbsp;singles)</pre>
<div class="block">Creates a new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Singles here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of the result of the individual <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>singles</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that terminates with the result (either success or error) of whichever amongst the
 passed <code>singles</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
